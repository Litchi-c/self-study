私以为，这章2.1节说的比较笼统，请把这章重点放在第一个进程的创建上，2.1节如果理解不了`透明性`,或者说为什么提供了几个系统调用就会带来路径名and交互的方便是没关系的，第五章？讲驱动程序接口的时候还回来细致的讲述这部分的。

***

# 第2章 操作系统组织

本章概述了如何组织操作系统以实现多路复用、隔离和交互。事实证明，有很多方法可以做到这一点，但本文主要关注以单片内核为中心的主流设计（许多Unix操作系统都使用单片内核)。

本章还概述了xv6进程的实现，进程是xv6中的隔离单元。最后，我们简单叙述了xv6启动时,第一个进程的创建的过程。xv6运行在多核RISC-V微处理器上，其许多低级功能(例如，进程的实现)都是特定于RISC-V的。

在一台完整的计算机中，CPU被支持的硬件包围，其中大部分以I/O接口的形式存在。xv6是在qemu的`-machine virt`选项模拟的硬件上编写的。支持的硬件包括RAM、ROM（存放启动代码）、与用户键盘/屏幕的串行连接以及用于存储的磁盘。

## 2.1 抽象物理资源

遇到操作系统时，人们可能会问的第一个问题是，为什么要使用它？

换句话说，可以将所有的系统调用实现为一个库，应用程序与之进行链接。在这个方案中，每个应用程序可以根据自己的需求定制自己的库。应用程序可以直接与硬件资源交互，并以应用程序的最佳方式(实现高性能或可预测的性能)使用这些资源。

一些用于嵌入式设备或实时系统的操作系统就是这样组织的。

这种方法的缺点是，容易导致后续进程的饥饿。(并且也比较考验程序员水平，毕竟高性能代码编写难度也不小)

> 饥饿：如果有多个应用程序在运行，则应用程序必须表现良好。 例如，每个应用程序必须定期放弃CPU，以便其他应用程序可以运行。如果所有应用程序都相互信任并且没有bug，那么这种协作分时方案就可以了。

对于应用程序来说，更典型的情况是彼此不信任，并且存在bug。因此人们通常希望提供的隔离性比协作方案提供的隔离更强大。

为了实现强隔离，禁止应用程序直接访问敏感的硬件资源，将资源抽象为服务是很有必要的。

Unix应用程序仅通过文件系统提供的open(),read(),write(),close(),这样的系统调用来与存储交互，而不是直接读取和写入磁盘。这为应用程序提供了路径名的便利，并允许操作系统(作为接口的实现者)管理磁盘。 即使不考虑隔离，有意进行交互(或只是希望避开对方)的程序，也可能会发现借助于文件系统是比直接使用磁盘更方便的。

类似地，Unix透明地在进程之间切换硬件CPU，根据需要保存和恢复寄存器状态，应用程序并不知道他们其实分时复用了CPU。操作系统依赖这种透明性，使应用程序之间能够共享CPU，即使某些应用程序处于无限循环中。

另一个例子是，Unix进程使用exec()构建其内存映像，而不是直接与物理内存交互。这允许操作系统来决定进程存放在内存中的位置；如果内存很吃紧，操作系统甚至可能将进程的一些数据存储在磁盘上（ps：或者随机选个幸运儿进程直接杀掉（for linux））。除此之外，exec()还为用户提供了文件系统存储可执行程序映像的便利。

图1.2中的系统调用接口经过精心设计，既为程序员提供了方便，又提供了强大隔离的可能性。**Unix接口不是抽象资源的唯一方法，但它已被证明是一种非常好的方法。**
## 2.2 特权模式与系统调用

强隔离要求应用程序和操作系统之间有一个硬边界。 如果应用程序出错，我们不希望操作系统或其他应用程序出现故障。相反，操作系统应该能够清理失败的应用程序并继续运行其他应用程序。为了实现强隔离，操作系统必须安排应用程序不能修改(甚至读取)操作系统的数据结构和指令，并且应用程序不能访问其他进程的内存。

CPU为强隔离提供硬件支持。例如，RISC-V有三种CPU可以执行指令的模式：Machine mode、Supervior mode和User mode。 在机器模式下执行的指令具有完全权限；CPU以机器模式启动。机器模式主要用于配置计算机。xv6在Machine mode下执行几行，然后更改为Supervior mode。

在Supervior mode中，CPU可以执行特权指令：例如，启用和禁用中断，读取和写入保存页表地址的寄存器等。如果User mode的应用程序尝试执行特权指令，则CPU不会执行该指令，但是会切换到Supervior mode，以便Supervior mode的代码可以终止应用程序。第1章中的图1.1说明了该组织。 应用程序只能执行User mode指令，并被称为在用户空间中运行，而处于Supervior mode的软件可以执行特权指令，并被称为在内核空间中运行。在内核空间(或Supervior mode)中运行的软件称为内核。

想要调用内核函数的应用程序(例如，xv6中的read())必须转换到内核。CPU提供一条特殊指令，将CPU从User mode切换到Supervior mode，并在内核指定的入口点进入内核。(RISC-V为此提供ecall指令。)一旦CPU切换到Supervior mode，内核就可以验证系统调用的参数，决定是否允许应用程序执行请求的操作，然后拒绝或执行它。

由内核来指定转换到Supervior mode的入口点是很关键的。如果应用程序可以决定内核入口点，那么恶意应用程序可能会在跳过参数验证的部分进入内核。

***

以下是我觉得有助于理解的两个点：
1. 默认情况下，RISC-V发生的所有的中断（interrupt）与异常（exception）都只能在M模式orS模式下处理。U模式不可以处理任何异常与中断，所以只要发生了中断or异常，CPU会捕获这些异常信号，然后提升特权等级来处理异常。
2. 如何处理异常呢？CPU会通过一个预先定义好的异常跳转表（这个是RISC-V ISA的规定）来跳转到对应异常的异常处理程序。异常处理程序有些是硬件已经写好的（缺页），有些是自己编写的（syscall）。

***

## 2.3 内核的组织

一个关键的设计问题是操作系统的哪一部分应该在Supervior mode下运行。

一种方法是，整个操作系统都驻留在内核中，因此所有系统调用的实现都在Supervior mode下运行。这种组织方法称为**单片内核**。 在这个组织方案中，整个操作系统以完全硬件权限运行。这个组织方案很方便，因为操作系统设计者不必决定操作系统的哪个部分不需要完全的硬件特权。此外，操作系统的不同部分更容易协作。例如，一个操作系统可能有一个缓冲区缓存，文件系统和虚拟内存系统都可以共享该缓存。

单一组织的一个缺点是操作系统不同部分之间的接口通常很复杂(我们将在本文的其余部分中看到)，因此操作系统开发人员很容易犯错误。在单片内核中，错误是致命的，因为Supervior mode中的错误通常会导致内核失败。如果内核失败，计算机停止工作，因此所有应用程序也会失败。计算机必须重新启动才能重新启动。

为了降低内核出错的风险，操作系统设计人员可以最小化在Supervior mode下运行的操作系统代码量，并在User mode下执行大部分操作系统代码。这种内核组织称为微内核。

![figure21](./picture/ch2figure21.png)

图2.1说明了这种微内核设计。在图中，文件系统作为用户级进程运行。作为进程运行的操作系统服务称为服务器。为了允许应用程序与文件服务器交互，内核提供了IPC的机制，以将消息从一个User mode进程发送到另一个User mode进程。例如，如果像shell这样的应用程序想要读取或写入文件，它会向文件服务器发送一条消息并等待响应。

在微内核中，内核接口由一些低级功能组成，用于启动应用程序、发送消息、访问设备硬件等。这种组织允许内核相对简单，因为大多数操作系统服务驻留在用户级服务器中。

与大多数Unix操作系统一样，xv6为单片内核。因此，xv6内核接口等同于操作系统接口，内核实现了全部的操作系统。由于xv6不提供很多服务，它的内核比一些微内核小，但从概念上讲，xv6是单片的。


ps:微内核不一定是优于宏内核（单片内核）的，在如果按照最初的那种我们将操作系统设计成一个库，尽管我们获得了最差的隔离性，但是我们也尽可能的减少了不必要的ipc，进而可以说是获得了最好的性能。而微内核是在牺牲效率的情况下，获得了一个强隔离性。实际在设计操作系统的过程中，应当综合考虑效率与安全的问题(这也是第一章所说的设计中的矛盾)

## 2.4 Code: xv6 organization

xv6内核源代码位于kernel目录中。源代码按照模块化的概念简单的划分成几个文件。模块间接口在defs.h(kernel/defs.h)中定义。

![figure23](./picture/ch2.assets/ch2figure22.png)

## 2.5 进程概览

进程是一个抽象概念，它让一个程序可以假设它独占一台机器。进程向程序提供“看上去”私有的，其他进程无法读写的内存系统(或地址空间)，以及一颗“看上去”仅执行该程序的CPU。

xv6 使用页表(由硬件实现)来为每个进程提供其独有的地址空间。页表将虚拟地址(RISC-V指令所使用的地址)翻译(或说“映射”)为物理地址(处理器芯片向主存发送的地址)。
![figure23](./picture/ch3.assets/ch2figure23.png)

xv6 为每个进程维护了不同的页表，这样就能够合理地定义进程的地址空间了。如图2-3所示，一片地址空间包含了从虚拟地址0开始的用户内存。它的地址最低处放置进程的指令，接下来则是全局变量，栈区，以及一个用户可按需拓展的“堆”区(malloc使用)。在地址空间的顶部xv6保留了一个供trampoline使用的页，和一个trapframe(在第四章解释)。

xv6内核为每个进程维护许多状态，并将其收集到struct proc中(kernel/proc.h:86)。进程最重要的内核状态是它的页表，它的内核堆栈及其运行状态。xv6 使用结构体 struct proc 来维护一个进程的状态，其中最为重要的状态是进程的页表，内核栈，当前运行状态。我们接下来会用 p->xxx 来指代 proc 结构中的元素。

每个进程都有一个运行线程(或简称为线程)来执行进程的指令。线程可以被暂时挂起，稍后再恢复运行。系统在进程之间切换实际上就是挂起当前运行的线程，恢复另一个进程的线程。线程的大多数状态(局部变量和函数调用的返回地址)都保存在线程的栈上。每个进程都有用户栈和内核栈(p->kstack)。

当进程运行用户指令时，只有其用户栈被使用，其内核栈则是空的。然而当进程(通过系统调用或中断)进入内核时，内核代码就在进程的内核栈中执行；进程处于内核中时，其用户栈仍然保存着数据，只是暂时处于不活跃状态。进程的线程交替地使用着用户栈和内核栈。要注意内核栈是用户代码无法使用的，这样即使一个进程破坏了自己的用户栈，内核也能保持运行。

当进程使用系统调用时(ecall)，处理器转入内核栈中，提升硬件的特权级，然后运行系统调用对应的内核代码。当系统调用完成时，又从内核空间回到用户空间：降低硬件特权级(mret)，转入用户栈，恢复执行系统调用指令后面的那条用户指令。线程可以在内核中“阻塞”，等待I/O, 在I/O结束后再恢复运行。

> p->state: 指示了进程的状态：新建、准备运行、运行、等待 I/O 或退出状态中。
> p->pagetable: 以RISC-V硬件期望的格式保存进程的页表。xv6使分页硬件在用户空间中执行线程时使用进程的p->pagetable。进程的页表还充当分配用于存储进程内存的物理页地址的记录。

## 2.6 Code: 启动xv6与第一个进程

下面描述的行为是针对一个核的，但是这个通过qemu构建的xv6使用了多个核心，程序实际上对所有的CPU核心都执行了相同的操作。

为了使xv6更具体，我们将概述内核如何启动和运行第一个进程。后续章节将更详细地描述本概述中显示的机制。

1. 当RISC-V计算机开机时，它会自动初始化并运行一个引导加载程序(boot loader)，该加载程序是存储在只读存储器(ROM)中。引导加载程序将xv6内核加载到内存中。这个时候RISC-V 分页硬件是被禁用的，虚拟地址直接映射到物理地址。因为这里用的是qemu，所以实际上行为是:qemu -kernel在0x80000000加载内核，并使CPU跳转到这个地址。kernel.ld将确保_entry被放置在0x80000000。

> 将内核放置在0x8000000而不是0x0的原因是什么？ 地址范围0x0:0x8000000 包含I/O设备。

2. 在Machine mode下，CPU从_entry(kernel/entry.S:6)开始执行xv6。
> _entry.S的作用是设置一个堆栈,栈指针(sp)被设置为sp = stack0 + 4096由于xv6的栈按照惯例被设置成向下增长，所以这个值实际上是栈顶。 堆栈的大小被声明在start.c

3. 在设置好堆栈之后，_entry的最后一步行动便是跳转到start.c
> start()执行一些仅在Machine mode下允许的配置，然后切换到supervisor mode开始执行main()。要进入supervisor mode，RISC-V提供指令mret。此指令最常用于从上一次调用从supervisor mode返回到Machine mode。从_entry.S跳转到start()是全程在Machine mode中进行的，所以start()需要先通过寄存器mstatus将之前的特权模式设置为supervisor mode，将main()的地址写入寄存器mepc中。这样的话，调用mret就可以达成我们的目的:即，在Supervisor mode中，执行main()。

4. 此时我们处于S-mode下：由于我们刚刚的设置，在调用mret之后，pc被设置w为main()的起始地址。main()初始化几个设备和子系统后，它通过调用userinit()(kernel/proc.c:212)创建第一个进程。

5. 第一个进程执行initcode.S(user/initcode.S:1)，它通过调用exec陷入内核。一旦内核完成exec()，它将返回到init进程中的用户空间。(这里发生了一次特权模式的转换，我们从S-mode变成了U-mode了！)init(user/init.c:15)根据需要创建一个新的控制台设备文件，然后将其作为文件描述符0、1和2打开。然后它在控制台上启动shell。
6. 系统启动了。(我们在U-mode中了)

以下是第三步中start()做的一些事情，具体可以去看源代码，注释结构之类的也很清晰。start()在Machine mode下的配置:

- 在寄存器stap(Supervisor Address Translation and Protection)中写入0，禁止supervisor mode下虚拟地址的转换。
- 将所有的中断与异常从machine mode委托给supervisor mode。
- 初始化定时器中断。
- ...

补充解释：
1. 通常M模式的程序在第一次进入S模式之前会把零写入satp以禁用分页，这是RISC-V ISA的规定。

委托：默认情况下，发生所有异常(不论在什么权限模式下)的时候，控制权都会被移交到M-mode的异常处理程序。但是Unix系统中的大多数系统调用都执行在S-mode下。M-mode的异常处理程序可以将异常重新导向S-mode，但这些额外的操作会减慢大多数异常的处理速度。因此，RISC-V 提供了一种异常委托机制。通过该机制可以选择性地将中断和同步异常交给S-mode处理，而完全绕过M-mode。

## 2.7 Real world

在现实世界中，人们可以找到单片内核和微内核。许多Unix内核都是单片的。例如，Linux有一个单片内核，尽管有些操作系统功能作为用户级服务器运行(e.g., the windowing system)。L4、Minix和QNX等内核被组织为带有服务器的微内核，并在嵌入式环境中得到广泛部署。

大多数操作系统都采用了进程概念，而且大多数的进程都与xv6相似。然而，现代操作系统在一个进程中支持多个线程，以允许单个进程利用多个CPU。支持一个进程中的多个线程，涉及到xv6所没有的相当多的机制，包括潜在的接口更改(例如，Linux的clone，一个fork的变体)，以控制进程线程共享的方面。

## 2.8 练习

You can use gdb to observe the very first kernel-to-user transition. Run make qemu-gdb. In another window, in the same directory, run gdb. Type the gdb command break *0x3ffffff10e, which sets a breakpoint at the sret instruction in the kernel that jumps into user space. Type the continue gdb command. gdb should stop at the breakpoint, about to execute sret. Type stepi. gdb should now indicate that it is executing at address 0x0, which is in user space at the start of initcode.S.
